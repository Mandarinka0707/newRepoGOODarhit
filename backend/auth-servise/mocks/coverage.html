
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">backend.com/forum/auth-servise/internal/controller/auth_grpc.go (100.0%)</option>
				
				<option value="file1">backend.com/forum/auth-servise/internal/controller/auth_http.go (92.6%)</option>
				
				<option value="file2">backend.com/forum/auth-servise/internal/repository/session_repository.go (100.0%)</option>
				
				<option value="file3">backend.com/forum/auth-servise/internal/repository/user_repository.go (87.0%)</option>
				
				<option value="file4">backend.com/forum/auth-servise/internal/usecase/auth_usecase.go (86.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// controller/auth_grpc.go
package controller

import (
        "context"

        "backend.com/forum/auth-servise/internal/entity"
        "backend.com/forum/auth-servise/internal/usecase"
        pb "backend.com/forum/proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
)

type AuthController struct {
        uc *usecase.AuthUsecase
        pb.UnimplementedAuthServiceServer
}

func NewAuthController(uc *usecase.AuthUsecase) *AuthController <span class="cov8" title="1">{
        return &amp;AuthController{uc: uc}
}</span>

func (c *AuthController) Register(
        ctx context.Context,
        req *pb.RegisterRequest,
) (*pb.RegisterResponse, error) <span class="cov8" title="1">{
        ucReq := &amp;usecase.RegisterRequest{
                Username: req.Username,
                Password: req.Password,
        }

        ucResp, err := c.uc.Register(ctx, ucReq)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;pb.RegisterResponse{UserId: ucResp.UserID}, nil</span>
}

func (c *AuthController) Login(
        ctx context.Context,
        req *pb.LoginRequest,
) (*pb.LoginResponse, error) <span class="cov8" title="1">{
        ucReq := &amp;usecase.LoginRequest{
                Username: req.Username,
                Password: req.Password,
        }

        ucResp, err := c.uc.Login(ctx, ucReq)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;pb.LoginResponse{
                Token:    ucResp.Token,
                Username: ucResp.Username, // Добавьте это
        }, nil</span>
}

func (c *AuthController) GetUser(
        ctx context.Context,
        req *pb.GetUserRequest,
) (*pb.GetUserResponse, error) <span class="cov8" title="1">{
        ucReq := &amp;usecase.GetUserRequest{UserID: req.Id}

        ucResp, err := c.uc.GetUser(ctx, ucReq)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;pb.GetUserResponse{
                User: convertUserToProto(ucResp.User),
        }, nil</span>
}

func convertUserToProto(user *entity.User) *pb.User <span class="cov8" title="1">{
        return &amp;pb.User{
                Id:        user.ID,
                Username:  user.Username,
                Role:      string(user.Role),
                CreatedAt: timestamppb.New(user.CreatedAt),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// controller/auth_http.go
package controller

import (
        "net/http"

        "backend.com/forum/auth-servise/internal/usecase"
        "github.com/gin-gonic/gin"
)

type HTTPAuthController struct {
        uc *usecase.AuthUsecase
}

func NewHTTPAuthController(uc *usecase.AuthUsecase) *HTTPAuthController <span class="cov8" title="1">{
        return &amp;HTTPAuthController{uc: uc}
}</span>

type HTTPRegisterRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

type HTTPLoginRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

func (ctrl *HTTPAuthController) Register(c *gin.Context) <span class="cov8" title="1">{
        var req HTTPRegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        <span class="cov8" title="1">ucReq := &amp;usecase.RegisterRequest{
                Username: req.Username,
                Password: req.Password,
        }

        ucResp, err := ctrl.uc.Register(c.Request.Context(), ucReq)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Используем gin.H вместо HTTPRegisterResponse
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "user_id": ucResp.UserID,
        })</span>
}

func (ctrl *HTTPAuthController) Login(c *gin.Context) <span class="cov8" title="1">{
        var req HTTPLoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        <span class="cov8" title="1">ucReq := &amp;usecase.LoginRequest{
                Username: req.Username,
                Password: req.Password,
        }

        ucResp, err := ctrl.uc.Login(c.Request.Context(), ucReq)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Используем gin.H вместо HTTPLoginResponse
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "token":    ucResp.Token,
                "username": ucResp.Username,
        })</span>
}

func (ctrl *HTTPAuthController) GetUser(ctx *gin.Context) <span class="cov8" title="1">{
        userID := ctx.Param("id")

        user, err := ctrl.uc.GetUserByID(ctx.Request.Context(), userID)
        if err != nil || user == nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, gin.H{
                "id":       user.ID,
                "username": user.Username,
        })</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package repository

import (
        "context"

        domain "backend.com/forum/auth-servise/internal/entity"
        "github.com/jmoiron/sqlx"
)

type SessionRepository interface {
        CreateSession(ctx context.Context, session *domain.Session) error
        GetSessionByToken(ctx context.Context, token string) (*domain.Session, error)
}

type sessionRepository struct {
        db *sqlx.DB
}

func NewSessionRepository(db *sqlx.DB) SessionRepository <span class="cov8" title="1">{
        return &amp;sessionRepository{db: db}
}</span>

func (r *sessionRepository) CreateSession(ctx context.Context, session *domain.Session) error <span class="cov8" title="1">{
        query := `INSERT INTO sessions (user_id, token, expires_at) VALUES ($1, $2, $3)`
        _, err := r.db.ExecContext(ctx, query, session.UserID, session.Token, session.ExpiresAt)
        return err
}</span>

func (r *sessionRepository) GetSessionByToken(ctx context.Context, token string) (*domain.Session, error) <span class="cov8" title="1">{
        query := `SELECT user_id, token, expires_at FROM sessions WHERE token = $1`
        session := &amp;domain.Session{}
        err := r.db.GetContext(ctx, session, query, token)
        return session, err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"

        domain "backend.com/forum/auth-servise/internal/entity"
)

// DBTX определяет интерфейс, который реализуют как *sqlx.DB, так и моки
type DBTX interface {
        QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
        GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

type UserRepository interface {
        CreateUser(ctx context.Context, user *domain.User) (int64, error)
        GetUserByUsername(ctx context.Context, username string) (*domain.User, error)
        GetUserByID(ctx context.Context, id int64) (*domain.User, error)
}

type userRepository struct {
        db DBTX
}

// NewUserRepository создает новый экземпляр UserRepository
func NewUserRepository(db DBTX) UserRepository <span class="cov8" title="1">{
        return &amp;userRepository{db: db}
}</span>

// CreateUser сохраняет пользователя и возвращает его ID
func (r *userRepository) CreateUser(ctx context.Context, user *domain.User) (int64, error) <span class="cov8" title="1">{
        query := `INSERT INTO users (username, password, role, created_at) VALUES ($1, $2, $3, $4) RETURNING id`
        var id int64
        err := r.db.QueryRowContext(ctx, query, user.Username, user.Password, user.Role, user.CreatedAt).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

// GetUserByUsername возвращает пользователя по имени
func (r *userRepository) GetUserByUsername(ctx context.Context, username string) (*domain.User, error) <span class="cov8" title="1">{
        query := `SELECT id, username, password, role, created_at FROM users WHERE username = $1`
        user := &amp;domain.User{}
        err := r.db.GetContext(ctx, user, query, username)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return user, nil</span>
}

// GetUserByID возвращает пользователя по ID
func (r *userRepository) GetUserByID(ctx context.Context, id int64) (*domain.User, error) <span class="cov8" title="1">{
        query := `SELECT id, username, password, role, created_at FROM users WHERE id = $1`
        user := &amp;domain.User{}
        err := r.db.GetContext(ctx, user, query, id)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// auth_usecase.go
package usecase

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "backend.com/forum/auth-servise/internal/entity"
        "backend.com/forum/auth-servise/internal/repository"
        "backend.com/forum/auth-servise/pkg/auth"
        "go.uber.org/zap"
        "golang.org/x/crypto/bcrypt"
)

type AuthUsecase struct {
        userRepo    repository.UserRepository
        sessionRepo repository.SessionRepository
        cfg         *auth.Config
        logger      *zap.Logger
}
type AuthUsecaseInterface interface {
        Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error)
        Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error)
        GetUserByID(ctx context.Context, userID string) (*entity.User, error)
        ValidateToken(ctx context.Context, req *ValidateTokenRequest) (*ValidateTokenResponse, error)
        GetUser(ctx context.Context, req *GetUserRequest) (*GetUserResponse, error)
}

func (uc *AuthUsecase) GetUserByID(ctx context.Context, userID string) (*entity.User, error) <span class="cov8" title="1">{
        id, err := strconv.ParseInt(userID, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user ID format")
        }</span>
        <span class="cov8" title="1">return uc.userRepo.GetUserByID(ctx, id)</span>
}

func NewAuthUsecase(
        userRepo repository.UserRepository,
        sessionRepo repository.SessionRepository,
        cfg *auth.Config,
        logger *zap.Logger,
) *AuthUsecase <span class="cov8" title="1">{
        return &amp;AuthUsecase{
                userRepo:    userRepo,
                sessionRepo: sessionRepo,
                cfg:         cfg,
                logger:      logger,
        }
}</span>

func (uc *AuthUsecase) Register(
        ctx context.Context,
        req *RegisterRequest,
) (*RegisterResponse, error) <span class="cov8" title="1">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("Failed to hash password", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">user := &amp;entity.User{
                Username:  req.Username,
                Password:  string(hashedPassword),
                Role:      entity.RoleUser,
                CreatedAt: time.Now(),
        }

        userID, err := uc.userRepo.CreateUser(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                uc.logger.Error("Failed to create user", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;RegisterResponse{UserID: userID}, nil</span>
}

func (u *AuthUsecase) Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) <span class="cov8" title="1">{
        user, err := u.userRepo.GetUserByUsername(ctx, req.Username)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid username or password")
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid username or password")
        }</span>

        // Генерация токена
        <span class="cov8" title="1">token, err := auth.GenerateToken(user.ID, user.Role, user.Username, u.cfg.TokenSecret, u.cfg.TokenExpiration)
        if err != nil </span><span class="cov0" title="0">{
                u.logger.Error("failed to generate token", zap.Error(err))
                return nil, fmt.Errorf("internal server error")
        }</span>

        // Создание сессии только если токен успешно сгенерировачн
        <span class="cov8" title="1">session := &amp;entity.Session{
                UserID:    user.ID,
                Token:     token,
                ExpiresAt: time.Now().Add(u.cfg.TokenExpiration),
        }

        if err := u.sessionRepo.CreateSession(ctx, session); err != nil </span><span class="cov0" title="0">{
                u.logger.Error("failed to create session", zap.Error(err))
                return nil, fmt.Errorf("internal server error")
        }</span>

        <span class="cov8" title="1">return &amp;LoginResponse{
                Token:    token,
                Username: user.Username,
        }, nil</span>
}

// func (uc *AuthUsecase) ValidateToken(
//         ctx context.Context,
//         req *ValidateTokenRequest,
// ) (*ValidateTokenResponse, error) {
//         uc.logger.Info("Token validation request")

//         token, err := auth.ParseToken(req.Token, uc.cfg.TokenSecret)
//         if err != nil || !token.Valid {
//                 uc.logger.Warn("Invalid token", zap.Error(err))
//                 return &amp;ValidateTokenResponse{Valid: false}, nil
//         }

//         claims, ok := token.Claims.(jwt.MapClaims)
//         if !ok {
//                 uc.logger.Warn("Invalid token claims")
//                 return &amp;ValidateTokenResponse{Valid: false}, nil
//         }

//         userID, ok := claims["user_id"].(float64)
//         if !ok {
//                 uc.logger.Warn("Invalid user_id in token")
//                 return &amp;ValidateTokenResponse{Valid: false}, nil
//         }

//         role, ok := claims["role"].(string)
//         if !ok {
//                 uc.logger.Warn("Invalid role in token")
//                 return &amp;ValidateTokenResponse{Valid: false}, nil
//         }

//         return &amp;ValidateTokenResponse{
//                 Valid:  true,
//                 UserID: int64(userID),
//                 Role:   role,
//         }, nil
// }

func (uc *AuthUsecase) GetUser(
        ctx context.Context,
        req *GetUserRequest,
) (*GetUserResponse, error) <span class="cov8" title="1">{
        uc.logger.Info("Get user request", zap.Int64("user_id", req.UserID))

        user, err := uc.userRepo.GetUserByID(ctx, req.UserID)
        if err != nil || user == nil </span><span class="cov8" title="1">{
                uc.logger.Error("User not found", zap.Error(err))
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov8" title="1">return &amp;GetUserResponse{User: user}, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
